<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>YouTube Song Queue - Sync Edition</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    :root {
      --md-sys-color-primary: #FF8A00;
      --md-sys-color-on-primary: #000000;
      --md-sys-color-primary-container: #FFB74D;
      --md-sys-color-on-primary-container: #000000;
      --md-sys-color-surface: #1C1B1F;
      --md-sys-color-on-surface: #E6E1E5;
      --md-sys-color-surface-container: #2D2B2F;
      --md-sys-color-on-surface-container: #E6E1E5;
      --md-sys-color-error: #CF6679;
      --md-sys-color-on-error: #000000;
      --md-sys-color-link: #FFB74D;
      --md-sys-color-on-link: #000000;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Roboto', sans-serif;
      background-color: var(--md-sys-color-surface);
      color: var(--md-sys-color-on-surface);
      line-height: 1.5;
    }

    .body-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 24px;
    }

    h1 {
      text-align: center;
      font-size: 2.5rem;
      margin-bottom: 32px;
      color: var(--md-sys-color-primary);
    }

    .input-container {
      display: flex;
      gap: 8px;
      margin-bottom: 24px;
    }

    .input-container button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .input-container .material-icons {
      font-size: 20px;
    }

    input[type="text"],
    input[type="password"] {
      flex: 1;
      padding: 12px 16px;
      border-radius: 12px;
      border: none;
      background-color: var(--md-sys-color-surface-container);
      color: var(--md-sys-color-on-surface-container);
      font-size: 16px;
    }

    input[type="text"]:focus,
    input[type="password"]:focus {
      outline: 2px solid var(--md-sys-color-primary);
    }

    button {
      padding: 12px 24px;
      border-radius: 12px;
      border: none;
      background-color: var(--md-sys-color-primary);
      color: var(--md-sys-color-on-primary);
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: var(--md-sys-color-primary-container);
    }

    #queue-display {
      background-color: var(--md-sys-color-surface-container);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 32px;
    }

    h2 {
      color: var(--md-sys-color-primary);
      margin-bottom: 16px;
    }

    .queue-item {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 16px;
      background-color: var(--md-sys-color-surface);
      border-radius: 12px;
      margin-bottom: 12px;
      transition: transform 0.2s;
    }

    .queue-item:hover {
      transform: translateY(-2px);
    }

    .queue-item-thumbnail {
      width: 120px;
      height: 68px;
      border-radius: 8px;
      object-fit: cover;
    }

    .queue-item-info {
      flex: 1;
    }

    .queue-position {
      color: var(--md-sys-color-on-surface);
      font-size: 0.75rem;
      margin-bottom: 4px;
      opacity: 0.6;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }

    .video-title {
      color: var(--md-sys-color-on-surface);
      font-weight: 500;
      margin-bottom: 8px;
      font-size: 1rem;
    }

    .queue-item-info a {
      color: var(--md-sys-color-link);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: color 0.2s;
    }

    .queue-item-info a:hover {
      color: var(--md-sys-color-primary-container);
    }

    .queue-item-info .material-icons {
      font-size: 16px;
      vertical-align: middle;
    }

    .current-playing {
      border: 2px solid var(--md-sys-color-primary);
    }

    .control-buttons {
      display: none;
      gap: 12px;
      justify-content: center;
      align-items: center;
      margin: 32px auto;
      width: 100%;
      max-width: 640px;
      flex-wrap: wrap;
    }

    .control-buttons button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      min-width: 120px;
      justify-content: center;
      flex: 0 1 auto;
    }

    .control-buttons .material-icons {
      font-size: 20px;
    }

    #video-container {
      display: none;
      margin: 32px auto;
      text-align: center;
      width: 100%;
      max-width: 640px;
    }

    #youtube-player {
      width: 100%;
      max-width: 640px;
      margin: 0 auto;
    }

    iframe {
      border-radius: 16px;
      overflow: hidden;
    }

    /* Add styles for the name input modal */
    .name-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .name-modal-content {
      background-color: var(--md-sys-color-surface-container);
      padding: 32px;
      border-radius: 16px;
      width: 90%;
      max-width: 400px;
      text-align: center;
    }

    .name-modal h2 {
      margin-bottom: 24px;
    }

    .name-modal input {
      width: 100%;
      margin-bottom: 16px;
    }

    /* Add styles for notifications */
    .notification {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background-color: var(--md-sys-color-surface-container);
      padding: 16px 24px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 1000;
    }

    .notification.show {
      opacity: 1;
    }

    .notification .material-icons {
      color: var(--md-sys-color-primary);
    }

    /* Add styles for the log section */
    .log-section {
      background-color: var(--md-sys-color-surface-container);
      border-radius: 16px;
      padding: 24px;
      margin: 32px auto;
      width: 100%;
      max-width: 640px;
    }

    .log-section h2 {
      margin-bottom: 16px;
    }

    .log-entries {
      max-height: 200px;
      overflow-y: auto;
      font-size: 0.875rem;
    }

    .log-entry {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background-color: var(--md-sys-color-surface);
      border-radius: 8px;
      margin-bottom: 8px;
      opacity: 0.8;
    }

    .log-entry .material-icons {
      font-size: 16px;
      color: var(--md-sys-color-primary);
    }

    .log-entry .timestamp {
      color: var(--md-sys-color-on-surface);
      opacity: 0.6;
      font-size: 0.75rem;
    }

    .log-entry .user {
      color: var(--md-sys-color-primary);
      font-weight: 500;
    }

    footer {
      text-align: center;
      margin-top: 64px;
      padding: 24px;
      background-color: var(--md-sys-color-surface-container);
      border-radius: 16px;
      font-size: 12px;
      color: var(--md-sys-color-on-surface-container);
      opacity: 0.6;
    }

    footer p {
      margin-bottom: 8px;
      line-height: 1.4;
    }

    footer p:last-child {
      margin-bottom: 0;
    }

    footer strong {
      color: var(--md-sys-color-on-surface-container);
      opacity: 0.8;
    }

    /* Add this to your existing styles */
    .sync-playback-button {
      display: none;
      justify-content: center;
      margin: 32px auto;
      width: 100%;
      max-width: 640px;
    }

    .sync-playback-button button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      min-width: 200px;
      justify-content: center;
      background-color: var(--md-sys-color-primary-container);
    }

    .sync-playback-button button:hover {
      background-color: var(--md-sys-color-primary);
    }
  </style>
</head>
<body>
<div class="body-container">
  <h1>YTM4 - Sync Edition ðŸŽµ</h1>

  <div class="input-container">
    <input type="text" id="youtube-url" placeholder="Paste YouTube URL here">
    <button id="add-to-queue"><span class="material-icons">add</span> Add</button>
    <button id="refresh-button"><span class="material-icons">refresh</span> Refresh</button>
  </div>

  <div id="queue-display">
    <h2>Queue</h2>
    <div id="queue-list"></div>
  </div>

  <div id="video-container">
    <div id="youtube-player"></div>
  </div>

  <div class="control-buttons">
    <button id="play-button"><span class="material-icons">play_arrow</span> Play</button>
    <button id="pause-button"><span class="material-icons">pause</span> Pause</button>
    <button id="next-button"><span class="material-icons">skip_next</span> Next</button>
  </div>

  <!-- Hidden programmatic controls that only receive events -->
  <div class="control-buttons" style="display: none;">
    <button id="programmatic-play-button"><span class="material-icons">play_arrow</span> Play</button>
    <button id="programmatic-pause-button"><span class="material-icons">pause</span> Pause</button>
    <button id="programmatic-next-button"><span class="material-icons">skip_next</span> Next</button>
  </div>

  <div class="sync-playback-button" id="sync-playback-button">
    <button><span class="material-icons">sync</span> Sync Playback</button>
  </div>

  <div class="log-section">
    <h2>Activity Log</h2>
    <div class="log-entries" id="log-entries"></div>
  </div>

  <div class="name-modal" id="name-modal">
    <div class="name-modal-content">
      <h2>Enter Your Name</h2>
      <input type="text" id="user-name" placeholder="Your name">
      <button id="submit-name">Join Session</button>
    </div>
  </div>

  <div class="notification" id="notification">
    <span class="material-icons">info</span>
    <span id="notification-text"></span>
  </div>

  <footer>
    <p><strong>Made by Timothy</strong></p>
    <p>
      This app is similar to Spotify's Jam featureâ€”a collaborative queue for YouTube music. It allows users to add songs to a shared queue, but playback is controlled by the host (who knows the password and has the equipment for centralized playback). 
    </p>
    <p>
      Individuals can use it if they guess the password, but I'm not sure what benefit it will give them using it alone if they could just make their own playlist or manually queue their own songs in the official app. If you happen to find this app by accident and are not in the same place as the one who controls the playback, this app might be pretty useless for you. 
    </p>
    <p>
      It's a very simple alternative to Spotify's feature, designed for situations when only YouTube is available. The queue list automatically refreshes every 30 seconds, but you can manually refresh it so you'll know what's playing or what's been added by others on-demand. Enjoy the music, and remember, it's only fun when you're in the same place as the host! ðŸŽ¶
    </p>
  </footer>
</div>

  <script>
    let queue = [];
    let player;
    let userName = sessionStorage.getItem('userName');
    let lastProcessedLogEntry = null; // Track the last processed log entry
    let lastAction = null; // Track the last action regardless of user
    const queueDisplay = document.getElementById('queue-list');
    const youtubeUrlInput = document.getElementById('youtube-url');
    const addButton = document.getElementById('add-to-queue');
    const refreshButton = document.getElementById('refresh-button');
    const nameModal = document.getElementById('name-modal');
    const userNameInput = document.getElementById('user-name');
    const submitNameButton = document.getElementById('submit-name');
    const controlButtons = document.querySelector('.control-buttons');
    const videoContainer = document.querySelector('#video-container');
    const notification = document.getElementById('notification');
    const notificationText = document.getElementById('notification-text');
    let YOUTUBE_API_KEY = null;
    let hasApiKey = false;
    const titleCache = new Map(); // Cache for video titles
    const logEntries = document.getElementById('log-entries');
    const syncPlaybackButton = document.getElementById('sync-playback-button');
    let hasInitialSync = false;

    // Show notification function
    function showNotification(message) {
      notificationText.textContent = message;
      notification.classList.add('show');
      setTimeout(() => {
        notification.classList.remove('show');
      }, 3000);
    }

    // Load configuration
    async function loadConfig() {
      try {
        const response = await fetch('config.json');
        const config = await response.json();
        YOUTUBE_API_KEY = config.youtube_api_key;
        hasApiKey = YOUTUBE_API_KEY && YOUTUBE_API_KEY !== "YOUR_API_KEY";
      } catch (error) {
        console.error('Error loading config:', error);
        hasApiKey = false;
      }
    }

    // Load queue from local storage or fetch from PHP
    async function loadQueue() {
      try {
        const response = await fetch('get_queue.php');
        const data = await response.json();
        
        // Check if the current song has changed
        if (queue.length > 0 && data.length > 0) {
          const currentSong = queue[0];
          const newCurrentSong = data[0];
          
          if (currentSong.videoId !== newCurrentSong.videoId) {
            addLogEntry('Song Changed', newCurrentSong.title || newCurrentSong.url);
          }
        }
        
        queue = data;
        updateQueueDisplay();
      } catch (error) {
        console.error('Error loading queue:', error);
      }
    }

    // Load activity log from server
    async function loadActivityLog() {
      try {
        const response = await fetch('get_log.php');
        const data = await response.json();
        
        // Process the latest log entry for state changes first
        if (data.entries && data.entries.length > 0) {
          const latestEntry = data.entries[0];
          processLogEntry(latestEntry);
          
          // Update button visibility based on sync state
          if (hasInitialSync) {
            syncPlaybackButton.style.display = 'none';
            controlButtons.style.display = 'flex';
          }
        }
        
        // Then update the display
        updateLogDisplay(data.entries);
      } catch (error) {
        console.error('Error loading activity log:', error);
      }
    }

    // Process log entry for state changes
    function processLogEntry(entry) {
      // Skip if this is the same action as the last one we processed
      if (lastProcessedLogEntry && lastProcessedLogEntry.action === entry.action) {
      return;
      }

      // Update last processed entry
      lastProcessedLogEntry = entry;

      switch (entry.action.toLowerCase()) {

        case 'play':
          if (queue.length > 0 && player) {
            const videoId = queue[0].videoId;
            if (videoId) {
              player.loadVideoById({
              videoId: videoId,
              playerVars: {
                'autoplay': 1,
                'playsinline': 1,
                'enablejsapi': 1,
                'origin': window.location.origin,
                'start': entry.position || 0
              }
              });

              if (entry.user !== userName) {
              showNotification(`${entry.user} started playing ${queue[0].title || 'a song'}`);
              }

              console.log('Playing video:', queue[0].title || 'a song', 'at position:', entry.position || 0);

            }
          }
          break;

        case 'pause':
          if (player) {

            player.pauseVideo();

            if (entry.user !== userName) {

              showNotification(`${entry.user} paused the video`);
              console.log('Pausing video at position:', entry.position || 0);
            }

          }
          break;

        case 'add':
          if (entry.user !== userName) {
          showNotification(`${entry.user} added a song to the queue`);
          }
          break;

        case 'song changed':
          if (entry.user !== userName) {
          showNotification(`${entry.user} changed the song`);
          }
          break;

      }
    }

    // Update log display
    function updateLogDisplay(entries) {
      // Only update if the entries are different
      const currentEntries = Array.from(logEntries.children).map(el => el.innerHTML);
      const newEntries = entries.map(entry => `
        <span class="timestamp">${entry.timestamp}</span>
        <span class="user">${entry.user}</span>
        <span class="material-icons">${getActionIcon(entry.action)}</span>
        <span>${entry.action}${entry.details ? `: ${entry.details}` : ''}</span>
      `);
      
      if (JSON.stringify(currentEntries) !== JSON.stringify(newEntries)) {
        logEntries.innerHTML = '';
        entries.forEach(entry => {
          const div = document.createElement('div');
          div.classList.add('log-entry');
          div.innerHTML = `
            <span class="timestamp">${entry.timestamp}</span>
            <span class="user">${entry.user}</span>
            <span class="material-icons">${getActionIcon(entry.action)}</span>
            <span>${entry.action}${entry.details ? `: ${entry.details}` : ''}</span>
          `;
          logEntries.appendChild(div);
        });
      }
    }

    // Save queue to server-side PHP
    function saveQueue() {
      fetch('save_queue.php', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ queue: queue })
      });
    }

    // Helper function to extract VIDEO_ID from a YouTube URL
    function extractVideoId(url) {
      const regex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/;
      const match = url.match(regex);
      return match ? match[1] : null;
    }

    // Fetch video titles using YouTube Data API with batching
    async function fetchVideoTitles(videoIds) {
      if (!hasApiKey || !videoIds.length) return new Map();
      
      // Filter out already cached IDs
      const uncachedIds = videoIds.filter(id => !titleCache.has(id));
      if (!uncachedIds.length) return titleCache;

      try {
        // YouTube API allows up to 50 videos per request
        const batchSize = 50;
        const results = new Map();
        
        for (let i = 0; i < uncachedIds.length; i += batchSize) {
          const batch = uncachedIds.slice(i, i + batchSize);
          const response = await fetch(
            `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${batch.join(',')}&key=${YOUTUBE_API_KEY}`
          );
          const data = await response.json();
          
          if (data.items) {
            data.items.forEach(item => {
              results.set(item.id, item.snippet.title);
            });
          }
        }

        // Update cache with new results
        results.forEach((title, id) => titleCache.set(id, title));
        return titleCache;
      } catch (error) {
        console.error('Error fetching video titles:', error);
        return titleCache;
      }
    }

    // Initialize YouTube Player
    function onYouTubeIframeAPIReady() {
      player = new YT.Player('youtube-player', {
        height: '360',
        width: '640',
        playerVars: {
          'playsinline': 1,
          'enablejsapi': 1,
          'origin': window.location.origin,
          'autoplay': 1,
          'controls': 1,
          'rel': 0,
          'showinfo': 0,
          'modestbranding': 1,
          'fs': 1,
          'cc_load_policy': 1,
          'iv_load_policy': 3,
          'enablejsapi': 1,
          'widget_referrer': window.location.href
        },
        events: {
          'onStateChange': onPlayerStateChange,
          'onError': onPlayerError,
          'onReady': onPlayerReady,
          'onApiChange': onApiChange
        }
      });
    }

    // Handle API change event
    function onApiChange(event) {
      console.log('API changed:', event);
    }

    // Handle player ready event
    async function onPlayerReady(event) {
      console.log('Player is ready');
      // Store player state
      window.playerState = {
        isPlaying: false,
        currentVideoId: null
      };
      // Enable programmatic control
      event.target.setPlaybackQuality('default');
      event.target.setPlaybackRate(1);

      // Show sync button initially
      syncPlaybackButton.style.display = 'flex';
      controlButtons.style.display = 'none';
    }

    // Handle player errors
    function onPlayerError(event) {
      console.error('Player error:', event.data);
      showNotification('Error playing video. Please try again.');
    }

    // Handle YouTube Player state changes
    function onPlayerStateChange(event) {
      // console.log('Player state changed:', event.data);
      // Update stored state
      if (window.playerState) {
        window.playerState.isPlaying = event.data === YT.PlayerState.PLAYING;
        window.playerState.currentVideoId = player.getVideoData().video_id;
      }

      if (event.data === YT.PlayerState.ENDED) {
        nextSong();
      }
    }

    // Add play button event listener

    document.getElementById('play-button').addEventListener('click', playQueue);

    // Modify pause button handler to log position and pause the video

    document.getElementById('pause-button').addEventListener('click', () => {

      if (player) {

        player.pauseVideo(); // Explicitly pause the video
        const currentPosition = player.getCurrentTime();
        
        
        addLogEntry('Pause', '', currentPosition);
        console.log('Manually Pausing video at position:', currentPosition);
        console.log('JSON:', queue[0]);
      }
    });

    // Modify playQueue function to use last pause position
    async function playQueue() {

      if (queue.length > 0) {

        const videoId = queue[0].videoId;

        if (videoId) {
          
          // Fetch latest log entries
          const response = await fetch('get_log.php');
          const data = await response.json();

          // Check if the most recent log entry has the action "pause"
          if (data.entries && data.entries.length > 0 && data.entries[0].action.toLowerCase() === 'pause') {

            const lastPauseEntry = data.entries[0];
            const startPosition = lastPauseEntry.position || 0;

            // Add log entry with the position
            addLogEntry('Play', queue[0].title, startPosition);
            player.seekTo(startPosition, true); // Seek to the last pause position
            player.playVideo();
            console.log('Manually Playing video at position:', startPosition);
            console.log('JSON:', queue[0]);

          } else {

            // Add log entry without position if no recent pause
            addLogEntry('Play', queue[0].title);
            console.log('JSON:', queue[0]);
            player.playVideo();
            
          }

        } else {

          showNotification('Invalid video URL');

        }

      } else {

        showNotification('Queue is empty');

      }
    }

    



    // Initial queue display
    updateQueueDisplay();

    // Load the YouTube Iframe API
    const tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    const firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    // Load queue from server when the page loads
    window.onload = async () => {
      await loadConfig();
      loadQueue();
      // Poll for queue updates every 5 seconds
      setInterval(loadQueue, 5000);
      // Poll for activity log updates every 2 seconds
      setInterval(loadActivityLog, 2000);
    };

    // Reload Queue
    refreshButton.addEventListener('click', () => {
      loadQueue();
    });

    // Show name modal if no name is set
    if (!userName) {
      nameModal.style.display = 'flex';
    } else {
      videoContainer.style.display = 'block';
      syncPlaybackButton.style.display = 'flex';
      controlButtons.style.display = 'none';
    }

    // Handle name submission
    submitNameButton.addEventListener('click', () => {
      const name = userNameInput.value.trim();
      if (name) {
        userName = name;
        sessionStorage.setItem('userName', name);
        nameModal.style.display = 'none';
        videoContainer.style.display = 'block';
        syncPlaybackButton.style.display = 'flex';
        controlButtons.style.display = 'none';
      }
    });

    // Update the queue display
    function updateQueueDisplay() {
      queueDisplay.innerHTML = '';
      if (!hasApiKey) {
        const warningDiv = document.createElement('div');
        warningDiv.style.cssText = `
          background-color: var(--md-sys-color-error);
          color: var(--md-sys-color-on-error);
          padding: 12px;
          border-radius: 8px;
          margin-bottom: 16px;
          font-size: 0.875rem;
        `;
        warningDiv.innerHTML = `
          <span class="material-icons" style="vertical-align: middle; margin-right: 8px;">warning</span>
          YouTube API key not configured. Video titles will not be displayed. To enable titles, replace the API key in the code.
        `;
        queueDisplay.appendChild(warningDiv);
      }
      queue.forEach((item, index) => {
        const div = document.createElement('div');
        div.classList.add('queue-item');
        div.innerHTML = `
          <img class="queue-item-thumbnail" src="https://img.youtube.com/vi/${item.videoId}/3.jpg" alt="Thumbnail">
          <div class="queue-item-info">
            <div class="queue-position">Queue Position: ${index + 1}</div>
            ${item.title ? `<div class="video-title">${item.title}</div>` : ''}
            <a href="${item.url}" target="_blank" rel="noopener noreferrer">${item.url} <span class="material-icons">open_in_new</span></a>
          </div>
        `;
        if (index === 0) div.classList.add('current-playing');
        queueDisplay.appendChild(div);
      });
    }

    // Get icon for different actions
    function getActionIcon(action) {
      switch (action.toLowerCase()) {
        case 'play':
          return 'play_arrow';
        case 'pause':
          return 'pause';
        case 'next':
          return 'skip_next';
        case 'add':
          return 'add';
        case 'remove':
          return 'remove';
        default:
          return 'info';
      }
    }

    // Add URL to queue and refresh display
    addButton.addEventListener('click', async () => {
      const url = youtubeUrlInput.value.trim();
      const videoId = extractVideoId(url);
      if (videoId && !queue.some(item => item.url === url)) {
        // Get title from cache or fetch if needed
        const titles = await fetchVideoTitles([videoId]);
        const title = titles.get(videoId) || null;
        
        queue.push({
          url: url,
          title: title,
          videoId: videoId
        });
        saveQueue();
        updateQueueDisplay();
        youtubeUrlInput.value = '';
        addLogEntry('Add', title || url);
        // Immediately load activity log after adding
        loadActivityLog();
      } else {
        alert('Invalid YouTube URL or already in queue');
      }
    });

    // Add log entry function
    async function addLogEntry(action, details = '', position = null) {
      try {
        // First check the latest log entry from server
        const response = await fetch('get_log.php');
        const data = await response.json();
        
        // Skip if this is the same action as the latest server entry
        if (data.entries && data.entries.length > 0) {
          const latestEntry = data.entries[0];
          if (latestEntry.action === action) {
            return;
          }
        }

        // Create timestamp in 12-hour format with consistent options
        const timestamp = new Date().toLocaleTimeString('en-US', { 
          hour: '2-digit', 
          minute: '2-digit',
          second: '2-digit',
          hour12: true,
          timeZone: 'UTC' // Use UTC to ensure consistent time across users
        });
        
        // Send log entry to server immediately
        fetch('update_log.php', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            timestamp: timestamp,
            user: userName,
            action: action,
            details: details,
            position: position
          })
        });
        
        // Update local display immediately
        const entry = document.createElement('div');
        entry.classList.add('log-entry');
        entry.innerHTML = `
          <span class="timestamp">${timestamp}</span>
          <span class="user">${userName}</span>
          <span class="material-icons">${getActionIcon(action)}</span>
          <span>${action}${details ? `: ${details}` : ''}${position !== null ? ` at ${position}` : ''}</span>
        `;
        logEntries.insertBefore(entry, logEntries.firstChild);
        
        // Keep only the last 50 entries
        while (logEntries.children.length > 50) {
          logEntries.removeChild(logEntries.lastChild);
        }
      } catch (error) {
        console.error('Error adding log entry:', error);
      }
    }

    // Add sync playback button click handler
    syncPlaybackButton.addEventListener('click', async () => {
      try {
        // First, fetch the latest log entry
        const response = await fetch('get_log.php');
        const data = await response.json();
        
        if (data.entries && data.entries.length > 0) {
          const latestEntry = data.entries[0];
          
          // Process the latest entry to sync playback
          processLogEntry(latestEntry);
          
          // Hide sync button and show regular controls
          syncPlaybackButton.style.display = 'none';
          controlButtons.style.display = 'flex';
          hasInitialSync = true;
        }
      } catch (error) {
        console.error('Error syncing playback:', error);
        showNotification('Error syncing playback. Please try again.');
      }
    });
  </script>
</body>
</html>
